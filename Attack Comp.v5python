{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\ncontroller_2 = Controller(PRIMARY)\near = Motor(Ports.PORT13, GearSetting.RATIO_18_1, True)\near2 = Motor(Ports.PORT14, GearSetting.RATIO_18_1, False)\nleft_motor_a = Motor(Ports.PORT11, GearSetting.RATIO_6_1, False)\nleft_motor_b = Motor(Ports.PORT16, GearSetting.RATIO_6_1, False)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b)\nright_motor_a = Motor(Ports.PORT12, GearSetting.RATIO_6_1, True)\nright_motor_b = Motor(Ports.PORT17, GearSetting.RATIO_6_1, True)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 319.19, 295, 40, MM, 0.1)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n\n\n# define variables used for controlling motors based on controller inputs\ncontroller_2_left_shoulder_control_motors_stopped = True\ncontroller_2_right_shoulder_control_motors_stopped = True\ndrivetrain_l_needs_to_be_stopped_controller_2 = False\ndrivetrain_r_needs_to_be_stopped_controller_2 = False\n\n# define a task that will handle monitoring inputs from controller_2\ndef rc_auto_loop_function_controller_2():\n    global drivetrain_l_needs_to_be_stopped_controller_2, drivetrain_r_needs_to_be_stopped_controller_2, controller_2_left_shoulder_control_motors_stopped, controller_2_right_shoulder_control_motors_stopped, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            \n            # calculate the drivetrain motor velocities from the controller joystick axies\n            # left = axis3 + axis1\n            # right = axis3 - axis1\n            drivetrain_left_side_speed = controller_2.axis3.position() + controller_2.axis1.position()\n            drivetrain_right_side_speed = controller_2.axis3.position() - controller_2.axis1.position()\n            \n            # check if the value is inside of the deadband range\n            if drivetrain_left_side_speed < 5 and drivetrain_left_side_speed > -5:\n                # check if the left motor has already been stopped\n                if drivetrain_l_needs_to_be_stopped_controller_2:\n                    # stop the left drive motor\n                    left_drive_smart.stop()\n                    # tell the code that the left motor has been stopped\n                    drivetrain_l_needs_to_be_stopped_controller_2 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the left motor next\n                # time the input is in the deadband range\n                drivetrain_l_needs_to_be_stopped_controller_2 = True\n            # check if the value is inside of the deadband range\n            if drivetrain_right_side_speed < 5 and drivetrain_right_side_speed > -5:\n                # check if the right motor has already been stopped\n                if drivetrain_r_needs_to_be_stopped_controller_2:\n                    # stop the right drive motor\n                    right_drive_smart.stop()\n                    # tell the code that the right motor has been stopped\n                    drivetrain_r_needs_to_be_stopped_controller_2 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the right motor next\n                # time the input is in the deadband range\n                drivetrain_r_needs_to_be_stopped_controller_2 = True\n            \n            # only tell the left drive motor to spin if the values are not in the deadband range\n            if drivetrain_l_needs_to_be_stopped_controller_2:\n                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n                left_drive_smart.spin(FORWARD)\n            # only tell the right drive motor to spin if the values are not in the deadband range\n            if drivetrain_r_needs_to_be_stopped_controller_2:\n                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n                right_drive_smart.spin(FORWARD)\n            # check the buttonL1/buttonL2 status\n            # to control ear2\n            if controller_2.buttonL1.pressing():\n                ear2.spin(FORWARD)\n                controller_2_left_shoulder_control_motors_stopped = False\n            elif controller_2.buttonL2.pressing():\n                ear2.spin(REVERSE)\n                controller_2_left_shoulder_control_motors_stopped = False\n            elif not controller_2_left_shoulder_control_motors_stopped:\n                ear2.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_2_left_shoulder_control_motors_stopped = True\n            # check the buttonR1/buttonR2 status\n            # to control ear\n            if controller_2.buttonR1.pressing():\n                ear.spin(FORWARD)\n                controller_2_right_shoulder_control_motors_stopped = False\n            elif controller_2.buttonR2.pressing():\n                ear.spin(REVERSE)\n                controller_2_right_shoulder_control_motors_stopped = False\n            elif not controller_2_right_shoulder_control_motors_stopped:\n                ear.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_2_right_shoulder_control_motors_stopped = True\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_2 = Thread(rc_auto_loop_function_controller_2)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# Begin project code\nclass Constants:\n  \"\"\"\n  Arena is 12 ft x 12 ft\n  6 tiles x 6 tiles\n  Tile is 2 ft x 2 ft\n\n  Arena can be represented as 6 x 6 array (0, 1, 2, 3, 4, 5)\n  Origin as left corner of our side of arena\n\n  Robots start facing opposite side of arena\n\n  This class is mainly just for stuff to remember\n  \"\"\"\n  tile_length = 24*0.18  # Side length of square tile (inches) in arena\n  arena_tiles_length = 6  # Amount of tiles in length of arena\n  arena_size = arena_tiles_length * tile_length  # Side length of square arena\n  arena_grid = 6, 6\n  robot_attack_start = 6, 1  # Attacking robot (opponent goal on their side)\n  robot_defend_start = 6, 4  # Defending robot (our goal on their side)\n\ndrivetrain.set_drive_velocity(1000, PERCENT)\ndrivetrain.set_turn_velocity(1000, PERCENT)\n\ndef pre_autonomous():\n    # actions to do when the program starts\n    brain.screen.clear_screen()\n    brain.screen.print(\"pre auton code\")\n    wait(1, SECONDS)\n\ndef autonomous():\n    brain.screen.clear_screen()\n    brain.screen.print(\"autonomous code\")\n    ear.spin_to_position(180, DEGREES)\n    ear2.spin_to_position(180, DEGREES)\n    drivetrain.drive_for(FORWARD, 17.6 , INCHES)\n    drivetrain.turn_for(RIGHT,75,DEGREES)\n    drivetrain.drive_for(FORWARD, 8.8 , INCHES)\n    drivetrain.drive_for(REVERSE, 8.8 , INCHES)\n\ndef user_control():\n    brain.screen.clear_screen()\n    # place driver control in this while loop\n    while True:\n        wait(20, MSEC)\n#create competition instance\ncomp = Competition(user_control, autonomous)\npre_autonomous()\nautonomous()","textLanguage":"python","rconfig":[{"port":[],"name":"controller_2","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"ear2","leftDir":"false","right":"ear","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"split","id":"primary"},"triportSourcePort":22},{"port":[13],"name":"ear","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[14],"name":"ear2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[11,16,12,17,0],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel4in","gear":"ratio6_1","gearRatio":"1:10","direction":"fwd","gyroType":"none","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null}],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.5","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}