{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nleft_drive_smart = Motor(Ports.PORT11, GearSetting.RATIO_6_1, False)\nright_drive_smart = Motor(Ports.PORT12, GearSetting.RATIO_6_1, True)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 299.24, 38.099999999999994, 40, MM, 1)\ncontroller_2 = Controller(PRIMARY)\near = Motor(Ports.PORT13, GearSetting.RATIO_18_1, True)\near2 = Motor(Ports.PORT14, GearSetting.RATIO_18_1, False)\nmotor_group_16_motor_a = Motor(Ports.PORT16, GearSetting.RATIO_36_1, True)\nmotor_group_16_motor_b = Motor(Ports.PORT17, GearSetting.RATIO_36_1, False)\nmotor_group_16 = MotorGroup(motor_group_16_motor_a, motor_group_16_motor_b)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n\n\n# define variables used for controlling motors based on controller inputs\ncontroller_2_left_shoulder_control_motors_stopped = True\ncontroller_2_right_shoulder_control_motors_stopped = True\ncontroller_2_x_b_buttons_control_motors_stopped = True\ndrivetrain_needs_to_be_stopped_controller_2 = False\n\n# define a task that will handle monitoring inputs from controller_2\ndef rc_auto_loop_function_controller_2():\n    global drivetrain_needs_to_be_stopped_controller_2, controller_2_left_shoulder_control_motors_stopped, controller_2_right_shoulder_control_motors_stopped, controller_2_x_b_buttons_control_motors_stopped, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            \n            # calculate the drivetrain motor velocities from the controller joystick axies\n            # left = axis3 + axis4\n            # right = axis3 - axis4\n            drivetrain_left_side_speed = controller_2.axis3.position() + controller_2.axis4.position()\n            drivetrain_right_side_speed = controller_2.axis3.position() - controller_2.axis4.position()\n            \n            # check if the values are inside of the deadband range\n            if abs(drivetrain_left_side_speed) < 5 and abs(drivetrain_right_side_speed) < 5:\n                # check if the motors have already been stopped\n                if drivetrain_needs_to_be_stopped_controller_2:\n                    # stop the drive motors\n                    left_drive_smart.stop()\n                    right_drive_smart.stop()\n                    # tell the code that the motors have been stopped\n                    drivetrain_needs_to_be_stopped_controller_2 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the motors next\n                # time the input is in the deadband range\n                drivetrain_needs_to_be_stopped_controller_2 = True\n            \n            # only tell the left drive motor to spin if the values are not in the deadband range\n            if drivetrain_needs_to_be_stopped_controller_2:\n                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n                left_drive_smart.spin(FORWARD)\n            # only tell the right drive motor to spin if the values are not in the deadband range\n            if drivetrain_needs_to_be_stopped_controller_2:\n                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n                right_drive_smart.spin(FORWARD)\n            # check the buttonL1/buttonL2 status\n            # to control ear2\n            if controller_2.buttonL1.pressing():\n                ear2.spin(FORWARD)\n                controller_2_left_shoulder_control_motors_stopped = False\n            elif controller_2.buttonL2.pressing():\n                ear2.spin(REVERSE)\n                controller_2_left_shoulder_control_motors_stopped = False\n            elif not controller_2_left_shoulder_control_motors_stopped:\n                ear2.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_2_left_shoulder_control_motors_stopped = True\n            # check the buttonR1/buttonR2 status\n            # to control ear\n            if controller_2.buttonR1.pressing():\n                ear.spin(FORWARD)\n                controller_2_right_shoulder_control_motors_stopped = False\n            elif controller_2.buttonR2.pressing():\n                ear.spin(REVERSE)\n                controller_2_right_shoulder_control_motors_stopped = False\n            elif not controller_2_right_shoulder_control_motors_stopped:\n                ear.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_2_right_shoulder_control_motors_stopped = True\n            # check the buttonX/buttonB status\n            # to control motor_group_16\n            if controller_2.buttonX.pressing():\n                motor_group_16.spin(FORWARD)\n                controller_2_x_b_buttons_control_motors_stopped = False\n            elif controller_2.buttonB.pressing():\n                motor_group_16.spin(REVERSE)\n                controller_2_x_b_buttons_control_motors_stopped = False\n            elif not controller_2_x_b_buttons_control_motors_stopped:\n                motor_group_16.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_2_x_b_buttons_control_motors_stopped = True\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_2 = Thread(rc_auto_loop_function_controller_2)\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# Begin project code\nclass Constants:\n  \"\"\"\n  Arena is 12 ft x 12 ft\n  6 tiles x 6 tiles\n  Tile is 2 ft x 2 ft\n\n  Arena can be represented as 6 x 6 array (0, 1, 2, 3, 4, 5)\n  Origin as left corner of our side of arena\n\n  Robots start facing opposite side of arena\n\n  This class is mainly just for stuff to remember\n  \"\"\"\n  tile_length = 24  # Side length of square tile (inches) in arena\n  arena_tiles_length = 6  # Amount of tiles in length of arena\n  arena_size = arena_tiles_length * tile_length  # Side length of square arena\n  arena_grid = 6, 6\n  robot_attack_start = 6, 1  # Attacking robot (opponent goal on their side)\n  robot_defend_start = 6, 4  # Defending robot (our goal on their side)\n\ndrivetrain.set_drive_velocity(100, PERCENT)\ndrivetrain.set_turn_velocity(100, PERCENT)\n\ndef autonomous(SIDE):\n  if SIDE == 1: # Defender\n    # Pushes 3 balls into the goal (hopefully), not accounting for changes\n    drivetrain.drive_for(FORWARD, Constants.tile_length, INCHES)\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    drivetrain.drive_for(FORWARD, Constants.tile_length, INCHES)\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    drivetrain.drive_for(FORWARD, Constants.tile_length, INCHES)\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    drivetrain.drive_for(FORWARD, 2 * Constants.tile_length, INCHES)\n\n  else:\n    # Push 3 balls to our side\n    drivetrain.drive_for(FORWARD, 2 * Constants.tile_length, INCHES)\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    drivetrain.drive_for(FORWARD, 2 * Constants.tile_length, INCHES)\n    drivetrain.drive_for(REVERSE, Constants.tile_length, INCHES)\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    drivetrain.drive_for(FORWARD, Constants.tile_length, INCHES)\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    drivetrain.drive_for(FORWARD, Constants.tile_length, INCHES)\n#autonomous(1)\ndrivetrain.turn_for(RIGHT, 3960,DEGREES)","textLanguage":"python","rconfig":[{"port":[11,12,0],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"wheel325in","gear":"ratio6_1","gearRatio":"1:1","direction":"fwd","gyroType":"none","width":"1.5","unit":"in","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[],"name":"controller_2","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"ear2","leftDir":"false","right":"ear","rightDir":"false","upDown":"","upDownDir":"false","xB":"motor_group_16","xBDir":"false","drive":"arcadel","id":"primary"},"triportSourcePort":22},{"port":[13],"name":"ear","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[14],"name":"ear2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[16,17],"name":"motor_group_16","customName":false,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio36_1","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22}],"slot":2,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}