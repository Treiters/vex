#region VEXcode Generated Robot Configuration
from vex import *
import urandom

# Brain should be defined by default
brain=Brain()

# Robot configuration code
left_drive_smart = Motor(Ports.PORT11, GearSetting.RATIO_6_1, False)
right_drive_smart = Motor(Ports.PORT12, GearSetting.RATIO_6_1, True)
drivetrain = DriveTrain(left_drive_smart, right_drive_smart, 478.78, 38.099999999999994, 40, MM, 1)
controller_2 = Controller(PRIMARY)
motor_13 = Motor(Ports.PORT13, GearSetting.RATIO_18_1, True)
motor_14 = Motor(Ports.PORT14, GearSetting.RATIO_18_1, False)


# wait for rotation sensor to fully initialize
wait(30, MSEC)


def play_vexcode_sound(sound_name):
    # Helper to make playing sounds from the V5 in VEXcode easier and
    # keeps the code cleaner by making it clear what is happening.
    print("VEXPlaySound:" + sound_name)
    wait(5, MSEC)

# add a small delay to make sure we don't print in the middle of the REPL header
wait(200, MSEC)
# clear the console to make sure we don't have the REPL in the console
print("\033[2J")



# define variables used for controlling motors based on controller inputs
controller_2_left_shoulder_control_motors_stopped = True
controller_2_right_shoulder_control_motors_stopped = True
drivetrain_needs_to_be_stopped_controller_2 = False

# define a task that will handle monitoring inputs from controller_2
def rc_auto_loop_function_controller_2():
    global drivetrain_needs_to_be_stopped_controller_2, controller_2_left_shoulder_control_motors_stopped, controller_2_right_shoulder_control_motors_stopped, remote_control_code_enabled
    # process the controller input every 20 milliseconds
    # update the motors based on the input values
    while True:
        if remote_control_code_enabled:
            
            # calculate the drivetrain motor velocities from the controller joystick axies
            # left = axis3 + axis4
            # right = axis3 - axis4
            drivetrain_left_side_speed = controller_2.axis3.position() + controller_2.axis4.position()
            drivetrain_right_side_speed = controller_2.axis3.position() - controller_2.axis4.position()
            
            # check if the values are inside of the deadband range
            if abs(drivetrain_left_side_speed) < 5 and abs(drivetrain_right_side_speed) < 5:
                # check if the motors have already been stopped
                if drivetrain_needs_to_be_stopped_controller_2:
                    # stop the drive motors
                    left_drive_smart.stop()
                    right_drive_smart.stop()
                    # tell the code that the motors have been stopped
                    drivetrain_needs_to_be_stopped_controller_2 = False
            else:
                # reset the toggle so that the deadband code knows to stop the motors next
                # time the input is in the deadband range
                drivetrain_needs_to_be_stopped_controller_2 = True
            
            # only tell the left drive motor to spin if the values are not in the deadband range
            if drivetrain_needs_to_be_stopped_controller_2:
                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)
                left_drive_smart.spin(FORWARD)
            # only tell the right drive motor to spin if the values are not in the deadband range
            if drivetrain_needs_to_be_stopped_controller_2:
                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)
                right_drive_smart.spin(FORWARD)
            # check the buttonL1/buttonL2 status
            # to control motor_14
            if controller_2.buttonL1.pressing():
                motor_14.spin(FORWARD)
                controller_2_left_shoulder_control_motors_stopped = False
            elif controller_2.buttonL2.pressing():
                motor_14.spin(REVERSE)
                controller_2_left_shoulder_control_motors_stopped = False
            elif not controller_2_left_shoulder_control_motors_stopped:
                motor_14.stop()
                # set the toggle so that we don't constantly tell the motor to stop when
                # the buttons are released
                controller_2_left_shoulder_control_motors_stopped = True
            # check the buttonR1/buttonR2 status
            # to control motor_13
            if controller_2.buttonR1.pressing():
                motor_13.spin(FORWARD)
                controller_2_right_shoulder_control_motors_stopped = False
            elif controller_2.buttonR2.pressing():
                motor_13.spin(REVERSE)
                controller_2_right_shoulder_control_motors_stopped = False
            elif not controller_2_right_shoulder_control_motors_stopped:
                motor_13.stop()
                # set the toggle so that we don't constantly tell the motor to stop when
                # the buttons are released
                controller_2_right_shoulder_control_motors_stopped = True
        # wait before repeating the process
        wait(20, MSEC)

# define variable for remote controller enable/disable
remote_control_code_enabled = True

rc_auto_loop_thread_controller_2 = Thread(rc_auto_loop_function_controller_2)

#endregion VEXcode Generated Robot Configuration

# ------------------------------------------
# 
# 	Project:      VEXcode Project
#	Author:       VEX
#	Created:
#	Description:  VEXcode V5 Python Project
# 
# ------------------------------------------

# Library imports
from vex import *

# Begin project code
class Constants:
  """
  Arena is 12 ft x 12 ft
  6 tiles x 6 tiles
  Tile is 2 ft x 2 ft

  Arena can be represented as 6 x 6 array (0, 1, 2, 3, 4, 5)
  Origin as left corner of our side of arena

  Robots start facing opposite side of arena

  This class is mainly just for stuff to remember
  """
  tile_length = 24  # Side length of square tile (inches) in arena
  arena_tiles_length = 6  # Amount of tiles in length of arena
  arena_size = arena_tiles_length * tile_length  # Side length of square arena
  arena_grid = 6, 6
  robot_attack_start = 6, 1  # Attacking robot (opponent goal on their side)
  robot_defend_start = 6, 4  # Defending robot (our goal on their side)

drivetrain.set_drive_velocity(100, PERCENT)
drivetrain.set_turn_velocity(100, PERCENT)

def autonomous(SIDE):
  if SIDE == 1: # Defender
    # Pushes 3 balls into the goal (hopefully), not accounting for changes
    drivetrain.drive_for(FORWARD, Constants.tile_length, INCHES)
    drivetrain.turn_for(LEFT, 90, DEGREES)
    drivetrain.drive_for(FORWARD, Constants.tile_length, INCHES)
    drivetrain.turn_for(RIGHT, 90, DEGREES)
    drivetrain.drive_for(FORWARD, Constants.tile_length, INCHES)
    drivetrain.turn_for(RIGHT, 90, DEGREES)
    drivetrain.drive_for(FORWARD, 2 * Constants.tile_length, INCHES)

  else:
    # Push 3 balls to our side
    drivetrain.drive_for(FORWARD, 2 * Constants.tile_length, INCHES)
    drivetrain.turn_for(RIGHT, 90, DEGREES)
    drivetrain.drive_for(FORWARD, 2 * Constants.tile_length, INCHES)
    drivetrain.drive_for(REVERSE, Constants.tile_length, INCHES)
    drivetrain.turn_for(LEFT, 90, DEGREES)
    drivetrain.drive_for(FORWARD, Constants.tile_length, INCHES)
    drivetrain.turn_for(RIGHT, 90, DEGREES)
    drivetrain.drive_for(FORWARD, Constants.tile_length, INCHES)
#autonomous(1)
drivetrain.turn_for(RIGHT, 360, DEGREES)
